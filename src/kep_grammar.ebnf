
Program         = { Item };

(* structs, enums, implements, traits later *)
Item            = ["pub"], ( FunctionDecl | Module | UseDecl );

(* --------- Items ---------- *)

(* generics later *)
FunctionDecl    = "fn", Identifier, [ GenericArgs ], "(", [ FunctionParams ], ")", [ "->", Type ], BlockExpression;
(* self param later *)
FunctionParams  = FunctionParam, { ",", FunctionParam }, [","];
FunctionParam   = Identifier, ":", Type;

Module          = "mod", Identifier, ";"
                | "mod", Identifier, "{", { Item } ,"}";

UseDecl         = "use", UseTree, ";";
UseTree         = UseIdent, { "::", UseTree }
                | "{", UseTree, { ",", UseTree }, [ "," ], "}"
                | "*";
UseIdent        = Identifier | "crate" | "super" | "self";

(* --------- Statements ---------- *)

Statement       = ";"
                | Item
                | LetStatement
                | ExpressionStatement ;

LetStatement    = "let", [ "mut" ], Identifier, [ ":", Type ], [ "=", Expression ], ";";

ExpressionStatement = Expression, ";" ;

(* --------- Expressions ---------- *)

Expression      = LiteralExpression
                | PathExpression
                | QualifiedExpressionPath
                | OperationExpression
                | GroupedExpression
                | CallExpression
                | ReturnExpression
                | UnderscoreExpression
                | IfExpression
                | LoopExpression
                | ArrayExpression
                | IndexExpression
                | TupleExpression
                | TupleIndexExpression
                | BlockExpression
                ;

LiteralExpression = STRING | INT | FLOAT | "true" | "false";

QualifiedExpressionPath = QualifiedPathType, "::", PathExpression;
QualifiedPathType   = "<", Type, ["as", TypePath], ">";
PathExpression      = PathSegment, { "::", PathSegment };
PathSegment         = PathIdentSegment, [ "::", GenericArgs ];
PathIdentSegment    = Identifier | "crate" | "super" | "self" | "Self";

OperationExpression = ArithmeticExpression
                    | NegationExpression
                    | ComparisonExpression
                    | LazyBooleanExpression
                    | AssignmentExpression;

ArithmeticExpression = Expression, ( "+" | "-" | "*" | "/" ), Expression;

NegationExpression = ( "-" | "!" ), Expression;

ComparisonExpression = Expression, ( "==" | "!=" | ">" | "<" | ">=" | "<=" ), Expression;

LazyBooleanExpression = Expression, ( "||" | "&&" ), Expression;

AssignmentExpression = Expression, ("="), Expression;

GroupedExpression = "(", Expression, ")";

CallExpression  = Expression, "(", [ CallParams ], ")";
CallParams      = Expression, { ",", Expression }, [","];

ReturnExpression = "return", [ Expression ];

UnderscoreExpression = "_";

IfExpression    = "if", Expression, BlockExpression, [ "else", ( BlockExpression | IfExpression ) ];

LoopExpression  = "loop", BlockExpression;

ArrayExpression = "[", [ ArrayElements ], "]" ;
ArrayElements   = Expression, ";", Expression
                | Expression, { ",", Expression }, [ "," ];

IndexExpression = Expression, "[", Expression, "]";

TupleExpression = "(", TupleElements, ")";
TupleElements = Expression, ",", { Expression, "," }, [ Expression ];

TupleIndexExpression = Expression, ".", INTEGER_LIT;

BlockExpression = "{", { Statement }, [ Expression ], "}";

(* --------- Types ---------- *)

Type            = ParenthType
                | TypePath
                | QualifiedTypePath
                | TupleType
                | ArrayType
                | SliceType
                ;

ParenthType     = "(", Type, ")";

QualifiedTypePath = QualifiedPathType, "::", TypePath;
TypePath        = TypePathSegment, { "::", TypePathSegment };
TypePathSegment = PathIdentSegment, [ "::" ], [ GenericArgs ];

GenericArgs     = "<", ">"
                | "<", GenericArg, { ",", GenericArg }, [ "," ], ">";
GenericArg      = Type;

TupleType       = "(", Type, ",", { Type, "," }, [ Type ], ")";

ArrayType       = "[", Type, ";", Expression, "]";

SliceType       = "[", Type, "]";

