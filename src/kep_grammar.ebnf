
Program         = { Item };

(* imports, structs, and enums later *)
Item            = ["pub"], ( FunctionDecl | Module | UseDecl );

(* --------- Items ---------- *)

(* generics later *)
FunctionDecl    = "fn", Identifier, "(", [ FunctionParams ], ")", [ "->", Type ], BlockExpression;

Module          = "mod", Identifier, ";"
                | "mod", Identifier, "{", { Item } ,"}";

UseDecl         = "use", UseTree, ";";
UseTree         = Identifier, { "::", UseTree }
                | "{", UseTree, { ",", UseTree }, [ "," ], "}"
                | "*";

(* self param later *)
FunctionParams  = FunctionParam, { ",", FunctionParam }, [","];
FunctionParam   = Identifier, ":", Type;

(* --------- Statements ---------- *)

Statement       = ";"
                | Item
                | LetStatement
                | ExpressionStatement ;

LetStatement    = "let", [ "mut" ], Identifier, [ ":", Type ], "=", Expression, ";" ;

ExpressionStatement = Expression, ";" ;

(* --------- Expressions ---------- *)

Expression      = LiteralExpression
                | PathExpression
                | OperationExpression
                | GroupedExpression
                | CallExpression
                | ReturnExpression
                | UnderscoreExpression
                | IfExpression
                | LoopExpression
                | ArrayExpression
                | IndexExpression
                | TupleExpression
                | TupleIndexExpression
                | BlockExpression
                ;

LiteralExpression = STRING | INT | FLOAT | "true" | "false";

PathExpression  = PathSegment, { "::", PathSegment };
PathSegment     = Identifier;

OperationExpression = ArithmeticExpression
                    | NegationExpression
                    | ComparisonExpression
                    | LazyBooleanExpression
                    | AssignmentExpression;

ArithmeticExpression = Expression, ( "+" | "-" | "*" | "/" ), Expression;

NegationExpression = ( "-" | "!" ), Expression;

ComparisonExpression = Expression, ( "==" | "!=" | ">" | "<" | ">=" | "<=" ), Expression;

LazyBooleanExpression = Expression, ( "||" | "&&" ), Expression;

AssignmentExpression = Expression, ("="), Expression;

GroupedExpression = "(", Expression, ")";

CallExpression  = Expression, "(", [ CallParams ], ")";
CallParams      = Expression, { ",", Expression }, [","];

ReturnExpression = "return", [ Expression ];

UnderscoreExpression = "_";

IfExpression    = "if", Expression, BlockExpression, [ "else", ( BlockExpression | IfExpression ) ];

LoopExpression  = "loop", BlockExpression;

ArrayExpression = "[", [ ArrayElements ], "]" ;
ArrayElements = Expression, ";", Expression
              | Expression, { ",", Expression }, [ "," ];

IndexExpression = Expression, "[", Expression, "]";

TupleExpression = "(", TupleElements, ")";
TupleElements = Expression, ",", { Expression, "," }, [ Expression ];

TupleIndexExpression = Expression, ".", INTEGER_LIT;

BlockExpression = "{", { Statement }, [ Expression ], "}";

(* --------- Types ---------- *)

Type            = ParenthType
                | TypePath
                | TupleType
                | ArrayType
                | SliceType
                ;

ParenthType     = "(", Type, ")";

TypePath        = TypePathSegment, { "::", TypePathSegment };
TypePathSegment = Identifier, [ "::" ], [ GenericArgs ];

GenericArgs     = "<", ">"
                | "<", Type, { ",", Type }, [ "," ], ">";

TupleType       = "(", Type, ",", { Type, "," }, [ Type ], ")";

ArrayType       = "[", Type, ";", Expression, "]";

SliceType       = "[", Type, "]";

