
Program         = { Item };

(* imports, structs, and enums later *)
Item            = ["pub"], ( FunctionDecl | Module | UseDecl );

(* generics later *)
FunctionDecl    = "fn", Identifier, "(", [ FunctionParams ], ")", [ "->", Type ], BlockExpression;

Module          = "mod", Identifier, ";"
                | "mod", Identifier, "{", { Item } ,"}";

UseDecl         = "use", UseTree, ";";
UseTree         = TODO;

(* self param later *)
FunctionParams  = FunctionParam, { ",", FunctionParam }, [","];
FunctionParam   = Identifier, ":", Type;

BlockExpression = "{", { Statement }, [ Expression ], "}";

Statement       = ";"
                | Item
                | LetStatement
                | ExpressionStatement ;

LetStatement    = "let", [ "mut" ], Identifier, [ ":", Type ], "=", Expression, ";" ;

ExpressionStatement = Expression, ";" ;

(* Expressions *)

Expression      = LiteralExpression
                | OperationExpression
                | GroupedExpression
                | CallExpression
                | ReturnExpression
                | UnderscoreExpression
                | IfExpression
                | LoopExpression
                | ArrayExpression
                | IndexExpression
                | TupleExpressions
                | TupleIndexExpression
                ;

LiteralExpression = STRING | INT | FLOAT | "true" | "false";

OperationExpression = ArithmeticExpression
                    | NegationExpression
                    | ComparisonExpression
                    | LazyBooleanExpression
                    | AssignmentExpression;

ArithmeticExpression = Expression, ( "+" | "-" | "*" | "/" ), Expression;

NegationExpression = ( "-" | "!" ), Expression;

ComparisonExpression = Expression, ( "==" | "!=" | ">" | "<" | ">=" | "<=" ), Expression;

LazyBooleanExpression = Expression, ( "||" | "&&" ), Expression;

AssignmentExpression = Expression, ("="), Expression;

GroupedExpression = "(", Expression, ")";

CallExpression  = Expression, "(", [ CallParams ], ")";
CallParams      = Expression, { ",", Expression }, [","];

ReturnExpression = "return", [ Expression ];

UnderscoreExpression = "_";

IfExpression    = "if", Expression, BlockExpression, [ "else", ( BlockExpression | IfExpression ) ];

LoopExpression  = "loop", BlockExpression;

ArrayExpression = "[", [ ArrayElements ], "]" ;
ArrayElements = Expression, ";", Expression
              | Expression, { ",", Expression }, [ "," ];

IndexExpression = Expression, "[", Expression, "]";

TupleExpression = "(", TupleElements, ")";
TupleElements = Expression, ",", { Expression, "," }, [ Expression ];

TupleIndexExpression = Expression, ".", INTEGER_LIT;

(* Types *)
Type            = FunctionType | ArrayType | TupleType | GenericType | SimpleType;

SimpleType      = Identifier;

GenericType     = Identifier, "<", TypeList, ">";
TypeList        = Type, { ",", Type }, [","];

ArrayType       = "[", Type, [ ";", INT ], "]";

TupleType       = "(", Type, ",", { Type, "," }, [ Type ], ")";

FunctionType    = "fn", "(", [ TypeList ], ")", "->", Type ;
